<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Livro AR — Carregamento Estável + Iluminação</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/",
        "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
      }
    }
  </script>

  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #ar{position:fixed;inset:0;width:100vw;height:100dvh;height:100svh;touch-action:none}
    #ar>video,#ar>canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    .ui{position:fixed;z-index:20;font:14px system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #loading{inset:0;display:flex;align-items:center;justify-content:center;color:#fff;background:rgba(0,0,0,.5)}
    :root{
      --glass: rgba(10,24,14,0.78);
      --stroke: rgba(255,255,255,0.12);
      --accent: linear-gradient(140deg,#c4f7c8,#7edfa5);
      --accent-strong: #2f8f52;
      --text: #e9f6eb;
      --muted: #cde9d2;
    }
    #toolbar{
      left:50%;transform:translateX(-50%);
      bottom:12px;display:flex;gap:12px;align-items:center;
      background:var(--glass);padding:10px 12px;border-radius:16px;color:var(--text);
      border:1px solid var(--stroke);backdrop-filter:blur(10px);box-shadow:0 10px 40px rgba(0,0,0,0.35);
    }
    #toolbar button{font:14px system-ui;padding:10px 18px;border-radius:999px;border:none;background:var(--accent);color:#0f2617;font-weight:700;letter-spacing:0.01em;display:flex;align-items:center;justify-content:center;gap:8px;cursor:pointer;box-shadow:0 8px 20px rgba(126,223,165,0.22);transition:transform 140ms ease,box-shadow 140ms ease,opacity 120ms ease;line-height:1}
    #toolbar button:hover{transform:translateY(-1px);box-shadow:0 10px 26px rgba(126,223,165,0.32)}
    #toolbar button:active{transform:translateY(0)}
    #toolbar button:disabled{opacity:0.55;cursor:not-allowed;box-shadow:none;transform:none}
    #badge{right:10px;top:10px;background:rgba(66,132,92,0.76);color:#e9f6eb;padding:6px 12px;border-radius:12px;border:1px solid var(--stroke);box-shadow:0 8px 24px rgba(0,0,0,0.35)}
    #scanningUI{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:transparent;z-index:10}
    .scanningBox{position:relative;width:60vmin;height:60vmin;border:4px solid white;border-radius:12px;box-shadow:0 0 20px rgba(0,0,0,0.5)}
    .scanningBox::after{content:"";position:absolute;inset:-9999px;border-radius:inherit;box-shadow:0 0 0 9999px rgba(0,0,0,0.35);pointer-events:none}
  </style>
</head>
<body>
  <div id="ar"></div>
  <div id="loading" class="ui">Iniciando...</div>
  <div id="scanningUI" class="ui"><div class="scanningBox"></div></div>
  <div id="toolbar" class="ui" style="display: none;">
    <button id="prevBtn"><span>Anterior</span></button>
    <button id="nextBtn"><span>Próxima</span></button>
  </div>
  <div id="badge" class="ui"></div>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
    import * as SkeletonUtils from "three/addons/utils/SkeletonUtils.js";
    import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
    import { MindARThree } from "mindar-image-three";

    const PAGES = [
      { label: "Capa", mind: "./targets/capa.mind", lightBoost: 1.35, materialBoost: 1.25, exposureBoost: 1.15, emissiveBoost: 0.4, colorBoost: 1.12, models: [
        { file: "./models/Capa.glb", portion: 1, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} },] },
      { label: "1 • Fonte", mind: "./targets/pag01.mind", lightBoost: 1.5, materialBoost: 1.3, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/anafonte.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "2 • Ana", mind: "./targets/pag02.mind", lightBoost: 1.5, materialBoost: 1.3, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/anafonte.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "3 • Minerva", mind: "./targets/pag03.mind", lightBoost: 1.5, materialBoost: 1.3, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/minervaearvore.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "4 • Bailarinas", mind: "./targets/pag04.mind", lightBoost: 1.5, materialBoost: 1.3, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/bailarinas.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "5 • Ana Mapa", mind: "./targets/pag05.mind", lightBoost: 2.0, materialBoost: 1.7, exposureBoost: 1.4, emissiveBoost: 0.8, colorBoost: 1.3, models: [{ file: "./models/anamapa.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "6 • Mapa", mind: "./targets/pag06.mind", lightBoost: 2.0, materialBoost: 1.7, exposureBoost: 1.4, emissiveBoost: 0.8, colorBoost: 1.3, models: [{ file: "./models/mapa.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "7 • Baobá", mind: "./targets/pag07.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/baobaceninha.glb", portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "8 • Recorte", mind: "./targets/pag08.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/recorte.glb",  portion: 1.2, pos:{x:0, y:0, z:0}, rot:{x:0, y:0, z:0} }] },
      { label: "9 • Ana no Banco", mind: "./targets/pag09.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/ananobanco.glb", portion: 1.2, pos:{x:0,y:0,z:0}, rot:{x:0,y:0,z:0} }] },
      { label: "10 • Chave", mind: "./targets/pag10.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/chave.glb", portion: 1.2, pos:{x:0,y:0,z:0}, rot:{x:0,y:0,z:0} }] },
      { label: "11 • Ana e Avó", mind: "./targets/pag11.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/anaeavo.glb", portion: 1.2, pos:{x:0,y:0,z:0}, rot:{x:0,y:0,z:0} }] },
      { label: "12 • Fim", mind: "./targets/pag12.mind", lightBoost: 1.6, materialBoost: 1.4, exposureBoost: 1.2, emissiveBoost: 0.5, colorBoost: 1.2, models: [{ file: "./models/fim.glb", portion: 1.2, pos:{x:0,y:0,z:0}, rot:{x:0,y:0,z:0} }] }
    ];

    const DEFAULT_ROT_X = 0;
    const MINDAR_PARAMS = { filterMinCF: 0.0003, filterBeta: 0.005, warmupTolerance: 2, missTolerance: 3, maxTrack: 1, uiScanning: "#scanningUI" };

    const container = document.getElementById("ar"),
          loadingEl  = document.getElementById("loading"),
          badgeEl    = document.getElementById("badge"),
          prevBtn    = document.getElementById("prevBtn"),
          nextBtn    = document.getElementById("nextBtn"),
          scanningUI = document.getElementById("scanningUI"),
          toolbarEl  = document.getElementById("toolbar");

    const loader = new GLTFLoader();
    const draco  = new DRACOLoader(); draco.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
    loader.setDRACOLoader(draco);

    const modelCache = new Map();
    const envCache = { tex: null };
    async function getModelClone(file){
      if (!modelCache.has(file)) {
        const gltf = await loader.loadAsync(file);
        modelCache.set(file, gltf.scene);
      }
      // sempre retorna um clone independente
      return SkeletonUtils.clone(modelCache.get(file));
    }

    // Opcional: “aquecimento” do cache do navegador
    async function warmUpBrowserCache() {
      const all = new Set();
      for (const p of PAGES) {
        all.add(p.mind);
        for (const m of p.models) all.add(m.file);
      }
      for (const url of all) fetch(url).catch(()=>{});
    }

    function fitCenterPlace(model, portion, pos, rot){
      const box = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3(); box.getCenter(center);
      model.position.sub(center);

      const group = new THREE.Group(); group.add(model);
      group.rotation.set(DEFAULT_ROT_X + (rot.x||0), rot.y||0, rot.z||0);
      group.updateMatrixWorld(true);

      const sizedBox = new THREE.Box3().setFromObject(group);
      const size = new THREE.Vector3(); sizedBox.getSize(size);
      const scale = portion / Math.max(size.x, size.y, size.z || 1e-6);
      group.scale.multiplyScalar(scale);
      group.position.set(pos.x||0, pos.y||0, pos.z||0);
      group.updateMatrixWorld(true);

      const finalBox = new THREE.Box3().setFromObject(group);
      group.position.z -= finalBox.min.z;
      return group;
    }

    let mindar = null;
    let currentIndex = 0;
    let pageToken = 0;

    function setControlsEnabled(enabled){
      const disabled = !enabled;
      prevBtn.disabled = disabled;
      nextBtn.disabled = disabled;
      toolbarEl.classList.toggle("loading", disabled);
    }

    async function stopAndClear(){
      if (mindar) {
        try { await mindar.stop(); } catch {}
        try {
          if (mindar.renderer) {
            mindar.renderer.setAnimationLoop(null);
            if (mindar.renderer.renderLists) mindar.renderer.renderLists.dispose();
            mindar.renderer.dispose();
          }
        } catch {}
        try {
          if (mindar.video && mindar.video.srcObject) {
            const tracks = mindar.video.srcObject.getTracks();
            if (tracks && tracks.length) tracks.forEach(t => t.stop());
          }
        } catch {}
      }
      document.querySelectorAll('.mindar-ui-overlay').forEach(el => el.remove());
      container.innerHTML = ""; mindar = null;
      await new Promise(r => setTimeout(r, 120));
    }

    async function startPage(index){
      const token = ++pageToken;
      setControlsEnabled(false);
      try {
        currentIndex = index;
        const cfg = PAGES[index]; badgeEl.textContent = cfg.label;

        loadingEl.textContent = `Carregando pagina ${index + 1}...`;
        loadingEl.style.display = "flex";
        scanningUI.style.display = "none";

        await stopAndClear();

        mindar = new MindARThree({ container, imageTargetSrc: cfg.mind, ...MINDAR_PARAMS });
        const { renderer, scene, camera } = mindar;

        // ===== RENDERER PBR / SOMBRAS =====
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent||"");
        const pageLightBoost = (cfg.lightBoost !== undefined && cfg.lightBoost !== null) ? cfg.lightBoost : 1;
        const pageMaterialBoost = (cfg.materialBoost !== undefined && cfg.materialBoost !== null) ? cfg.materialBoost : 1;
        const pageExposureBoost = (cfg.exposureBoost !== undefined && cfg.exposureBoost !== null) ? cfg.exposureBoost : 1;
        const pageEmissiveBoost = (cfg.emissiveBoost !== undefined && cfg.emissiveBoost !== null) ? cfg.emissiveBoost : 0;
        const pageColorBoost = (cfg.colorBoost !== undefined && cfg.colorBoost !== null) ? cfg.colorBoost : 1;
        const emissiveWhite = new THREE.Color(0xffffff);
        const emissiveTint = new THREE.Color(0x1a1a1a).multiplyScalar(pageMaterialBoost);
        const baseEmissive = isMobile ? 0.45 : 0.15;
        renderer.toneMappingExposure = (isMobile ? 1.6 : 1.0) * pageExposureBoost;
        renderer.physicallyCorrectLights = true;
        renderer.shadowMap.enabled = false;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // ===== IBL (RoomEnvironment) + luz ambiente =====
        if (!envCache.tex) {
          const pmrem = new THREE.PMREMGenerator(renderer);
          envCache.tex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
          pmrem.dispose();
        }
        scene.environment = envCache.tex;
        scene.background  = null;
        scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, (isMobile ? 1.0 : 0.35) * pageLightBoost));
        scene.add(new THREE.AmbientLight(0xffffff, (isMobile ? 0.35 : 0.08) * pageLightBoost));

        // ===== Anchor e rig de luzes preso ao alvo =====
        const anchor = mindar.addAnchor(0);

        const lightRig = new THREE.Group();
        anchor.group.add(lightRig);

        const key = new THREE.DirectionalLight(0xffffff, (isMobile ? 2.1 : 1.35) * pageLightBoost);
        key.position.set(0.8, 1.2, 0.8);
        key.castShadow = true;
        key.shadow.mapSize.set(1024, 1024);
        key.shadow.camera.near = 0.01;
        key.shadow.camera.far  = 4.0;
        key.shadow.camera.left = -1; key.shadow.camera.right = 1;
        key.shadow.camera.top  =  1; key.shadow.camera.bottom = -1;
        key.shadow.bias = -0.0005;
        key.shadow.normalBias = 0.02;
        lightRig.add(key);

        const fill = new THREE.DirectionalLight(0xffffff, (isMobile ? 0.9 : 0.45) * pageLightBoost);
        fill.position.set(-0.8, 0.8, 0.3);
        lightRig.add(fill);

        const rim = new THREE.DirectionalLight(0xffffff, (isMobile ? 0.45 : 0.25) * pageLightBoost);
        rim.position.set(0.0, 0.3, -0.8);
        lightRig.add(rim);

        // Plano receptor de sombra (tamanho ~ da página)
        const shadowPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(1.2, 1.2),
          new THREE.ShadowMaterial({ opacity: 0.35 })
        );
        shadowPlane.receiveShadow = true;
        shadowPlane.renderOrder = 0;
        shadowPlane.position.z = 0.0002;
        anchor.group.add(shadowPlane);

        anchor.onTargetFound = () => { anchor.group.visible = true; scanningUI.style.display = "none"; };
        anchor.onTargetLost  = () => { anchor.group.visible = false; scanningUI.style.display = "flex"; };

        anchor.group.visible = false;

        const onResize = ()=>{
          const w = container.clientWidth, h = container.clientHeight;
        const maxDpr = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent||"") ? 1.35 : 2;
        renderer.setSize(w, h);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, maxDpr));
        camera.aspect = w / h; camera.updateProjectionMatrix();
      };
        window.addEventListener("resize", onResize, { once:true }); onResize();
        renderer.setAnimationLoop(()=>renderer.render(scene, camera));

        // Inicia a camera/scan antes de carregar GLB para evitar espera
        await mindar.start();
        if (mindar.controller && mindar.controller.reset) {
          try { mindar.controller.reset(); } catch {}
        }
        loadingEl.style.display = "none";
        scanningUI.style.display = "flex";

        // ===== Modelos (assincrono, para nao travar camera) =====
        await Promise.all(cfg.models.map(async (modelCfg) => {
          const clone = await getModelClone(modelCfg.file);

          clone.traverse(n => {
            if (!n.isMesh) return;
            if (pageColorBoost > 1 && n.geometry && n.geometry.attributes && n.geometry.attributes.color) {
              n.geometry = n.geometry.clone();
              const colorAttr = n.geometry.attributes.color;
              for (let i = 0; i < colorAttr.count; i++) {
                const r = Math.min(colorAttr.getX(i) * pageColorBoost, 1);
                const g = Math.min(colorAttr.getY(i) * pageColorBoost, 1);
                const b = Math.min(colorAttr.getZ(i) * pageColorBoost, 1);
                colorAttr.setXYZ(i, r, g, b);
              }
              colorAttr.needsUpdate = true;
            }
            if (Array.isArray(n.material)) {
              n.material = n.material.map((m) => (m ? m.clone() : m));
            } else if (n.material) {
              n.material = n.material.clone();
            }
            n.castShadow = true;
            const mats = Array.isArray(n.material) ? n.material : [n.material];
            mats.forEach((mat) => {
              if (!mat) return;
              if (mat.color) {
                const boost = mat.isMeshBasicMaterial ? (isMobile ? 1.6 : 1.1) : (isMobile ? 1.25 : 1.05);
                mat.color.multiplyScalar(boost * pageMaterialBoost);
              }
              if ((mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) && !mat.emissiveMap) {
                if (mat.emissive && mat.emissive.r === 0 && mat.emissive.g === 0 && mat.emissive.b === 0) {
                  mat.emissive.copy(emissiveTint);
                }
                mat.emissiveIntensity = Math.max(mat.emissiveIntensity || 0, baseEmissive * pageMaterialBoost);
              } else if (mat.emissive !== undefined && pageEmissiveBoost > 0) {
                mat.emissiveIntensity = Math.max(mat.emissiveIntensity || 0, baseEmissive * pageMaterialBoost);
              }
              if (mat.emissive !== undefined && pageEmissiveBoost > 0) {
                if (mat.map && !mat.emissiveMap) {
                  mat.emissiveMap = mat.map;
                  mat.emissive.copy(emissiveWhite);
                }
                mat.emissiveIntensity = Math.max(mat.emissiveIntensity || 0, baseEmissive * pageMaterialBoost + pageEmissiveBoost);
              }
              if (pageEmissiveBoost > 0 && mat.metalness !== undefined) {
                mat.metalness = Math.min(mat.metalness, 0.35);
              }
              if (mat.envMapIntensity !== undefined) mat.envMapIntensity = (isMobile ? 1.9 : 1.1) * pageMaterialBoost;
            });
          });

          const finalGroup = fitCenterPlace(clone, modelCfg.portion, modelCfg.pos, modelCfg.rot);
          anchor.group.add(finalGroup);
        }));
      } finally {
        if (token === pageToken) setControlsEnabled(true);
      }
    }

    async function main() {
      const urlP = Number(new URLSearchParams(location.search).get("p"));
      currentIndex = Number.isFinite(urlP) && urlP >= 0 && urlP < PAGES.length ? urlP : 0;

      toolbarEl.style.display = "flex";
      await startPage(currentIndex);
      warmUpBrowserCache().catch(()=>{});

      prevBtn.onclick = ()=> startPage( (currentIndex - 1 + PAGES.length) % PAGES.length );
      nextBtn.onclick = ()=> startPage( (currentIndex + 1) % PAGES.length );
    }

    main().catch(err => {
      console.error("Falha fatal ao iniciar a aplicação:", err);
      loadingEl.textContent = "Ocorreu um erro. Verifique o console.";
    });
  </script>
</body>
</html>
